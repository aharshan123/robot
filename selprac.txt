  xpath by attribute
//tag_name[@attribute_name = "value"]


xpath by multiple attributes 
//tag_name[@att_name = 'value' and @att_name = 'value']


xpath by group by index 
(xpath)[index]


xpath by text()
//tag_name[text()= 'text_value']
//tag[.= 'text_value']


xpath by contains
//tag_name[contains(@attr, 'attr_value')]
//tag_name[contains(text(), 'text_value')]
//tag_name[contains(., 'value')]

xpath for completely dynamic element
(//tag_name[., 'text_value'])/..//tag_name[index]


dropdown 
dropdown is a set of options or collections of options 
standard drop down (created in Select class)
non standard dropdown (created with other classes except Select)


from selenium.webdriver.support.select import Select
dd_ele = driver.find_element("xpath", (xpath))
dd = Select(dd_ele)
dd.select_by_index(index)
dd.select_by_value('value')
dd.select_by_visible_text('text')

dd.deselect_by_index(index)
dd.deselect_by_value(value)
dd.deselect_by_visible_text('text')
dd.deselect_all()

dd.options  (it returns address of all the options)
for i in dd.options:
   print(i.text)

dd.all_selected_options   (it return address of only selected options)

links = driver.find_elements('xpath', '//a')
print(len(links))
text_f = driver.find_elements('xpath', '//input')
img = driver.find_elements('xpath' '//img')
dd = driver.find_elements('xpath', '//select)




from selenium.webdriver.common.actionchains import ActionChains

a = ActionChains(driver)
a.move_to_element(web_ele).perform()
a.drag_and_drop(sourc, dest).perform()
a.double_click(web_ele).perform()
a.context_click(web_ele).perform)


to scroll_down
driver.execute_script("window.scrollBy(x,y)")
to scroll up
driver.execute_script("window.scrollTo(x,y)")

ele = driver.find_element('xpath', 'xpath')
d = ele.location
driver.execute_script(f"window.scrollBy({d['x']}, {d['y']})")


Keyboard actions

to perform keyboard actions we use Keys module
web_ele.send_keys(Keys.BACK_SPACE)
web_ele.send_keeys(Keys.CONTROL + 'a')
web_ele.send_keys(Keys.ENTER)

Frames 
 
a webpage inside an another webpage is known as frames or nested frame or embedded frame

to switch control from parent to child

driver.swith_to.frame(index/name_value/frame_address)  #NosuchframeExceptions

to switch from child to parent

driver.switch_to.parent_frame()  #it swith from child to its own parent
driver.switch_to.default_content() #it switch from child to main parent


to save screenshot
driver.save_screenshot('file_name.png')
to get current_time
datetime.now().strftime("%d-%m-%y %H-%M-%S")

Handling Popup's
a popup is a small window or tab

1.alert and confirmation popup  #we can't inspect or we can't drag

to automate alert and confirmation popup first we need to switch controm from 
webpage to alert popup

a = driver.switch_to.alert
a.accept()
a.dismiss()

2. hidden division popup 
initially it will be hidden once we perform some actions i will popup
here we can inspect but we can't drag
to automate we use send_keys(), click(), find_element()

3.child browser
a browser inside a browser is called child browser
by default control will be present in parent window we need to switch control from parent to child window

driver.switch_to.window(window_address)

to get window address
driver.current_window_handle #it returns only parent window address
driver.window_handales  #it will return list of parent window followed by child window adress

DATA DRIVEN TESTING

#steps to read the data from excel file
1. first we need to open the file
from xlrd import *
file = open_workbook("path")
sheet = file.sheet_by_name("sheet_name")
data = sheet.row_values(rownum, start_cl, end_cl)

to get number of row
sheet.nrows
to get number of columns
sheet.ncols

from selenium.webdriver.support.select import Select
from xlrd import *
wb = open_workbook("file_path)
sheet = wb.sheet_by_name("name")
print(sheet.row_values[2])


Synchronisation

the process of matching selenium speed with application speed is called is synchronization.

1.sleep(sec)
2.driver.implicitly_wait(sec)
3.WebDriverWait/explicit wait
from selenium.webdriver.support.wait import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC

wait = WebDriverWait(driver, sec)
wait.unti(EC.method(args)

methods
EC.title_is("title")
EC.title_contains("partial_title")
EC.url_to_be("url")
EC.url_contains("partial_url")
EC.visibility_of_element_located(("xpath", 'path'))



PYTEST
pytest is unit testing framework basically used by developer
as a test engineer
we use pytest to execute method/functions automatically
we use pytest to achieve parallel execution
we use pytest to run multiple testcases at oneshot
we use it to generate reports

naming convention
function/method name should start with test
class name should start with Test
file name should start with/ends with test

Markers
markers are used to execute a specific function/method/class/module
got classified into 2 types
1.built in markers
2.custom markers

custom markers
@pytest.mark.markerName

built in markers
1.@pytest.mark.skip(reason='')
2.@pytest.mark.skipif(cndition,reason='')
3.@pytest.mark.xfail
4.@pytest.mark.parameterise("var1, var2", [[v1,v2],[v1,v2]...]]
5.@pytest.fixture(autouse = False)

FIXTURE

fixture is kind of decorator which exectes before and after test function
fixture should not start with test

@pytest.fixture
def launch():
    driver = Chrome()
    driver.get(url)
    driver.implicitly_wait(sec)
    yield driver
    driver.quit()




What is Page Object Model (POM)?
One way to help write clean and well-tested code is to create a Page Object Model.
A Page Object Model (POM) is a set of classes designed to represent one or more web pages. It is a way of using objects to represent elements on the
page. This enables you to write code that is simple and easy to understand. It also helps you to keep your tests well-structured and understandable.

There are many benefits to creating a POM such as:

1.Testing Quality – The POM helps you write tests that are easy to understand and maintain.
This can help improve the quality of your testing process to improve the readability and reliability of the scripts.
2.Site Maintenance – It is easier to maintain the site over time. Suppose if something got changed on any page,
we could easily find the functions and locators that need to be changed by that page class.
3.Team Collaboration – The POM can help with collaboration between team members and improve the efficiency of your team significantly.
Overall Productivity – The POM can make it easier for new team members to get up to speed and boost overall team productivity.
4.Reusing Code – Using POM, we can reuse our functions in different Test Scripts by importing them from Page Class.
It doesn’t require writing the same functions in different test cases.
With all of these benefits, it is clear that a POM can be a valuable tool for any organization. By creating one, you can help improve the
quality of your software testing process and team collaboration.

*pom will consists of 3 stages,
1.declaration:
    here we should develope method for all the elements of a webpage
2.initialization:
   we should initialize a constructor with driver and an argument and make it as instance(self variable)
3.utilization:
   import the pom class module and create an object and utilize/call all the methods in test function(pytest)

rules of pom:
-------------
*entire webpage should be consider as individual POM file.
(1entire webpage = 1POM class)
*each POM class should consists of and all the element of the webpage should be present in that POM file
*POM file name and class should be same as webpage name
*POM file and class should not starts/ends with test.
*method name should be same as element name and shoule not starts with test keyword
*one constructor should be present in POM class and should accept driver as argument.
##########################################################################################################
"""
*conftest is a special file, in pytest which we can store only fixtures.
*conftest is like a repository.
*file name should be conftest.py
*always fixture name should be the 1st argument in each test function.
*main advantage of conftest file is without writing import stmt  in test_case module file, we can
directly access.
*because when we write fixture name always 1st it will go and search inside conftest file and execute.
"""
#############################################################################################################################################
"""
how to generate html report:
****************************
*to generate html report of test case execution we should install "pytest-html" module/plugin.
*file --> settings -> click on project -> click on python interpreter --> click on plus -->
search for pytest-html --> click on install package --> once after installing "successful message will appear"

*to generate html report and it will store in current location,
    >>pytest -rp filename.py --html="report-name.html"
*to generate html report on batch execution,
    >>pytest -rp --html="report-name.html"
(in above both execution will store in current location)

*command to generate html file and store in particular location/folder,
    >>pytest -rp --html="../folder-name/report-name.html"

note:
-----
*insted of -rp(report portal) we can write -vs, but -vs wont print message in report, so when ever
we are generating html report better to write -rp.
"""

HYBRID FRAMEWORK FLOW

“In my current project, we implemented a Hybrid Automation Framework using Python, Selenium, and Pytest.
 It's a blend of multiple approaches like POM, Data-Driven Testing, and modular scripting, organized in a scalable way.”

✅ Folder Structure & Components Explanation
Folder / Module	Purpose
generic/	Contains reusable utility functions like waits, logging, browser setup, and screenshot capture.
testcases/	Houses all automation test scripts, written using Pytest. Each test imports POM classes and utilities.
pom/	        Page Object Model classes that store locators and reusable page-level methods for UI interaction.
screenshots/	Automatically saves screenshots on failure for debugging and report attachment.
reports/	Stores HTML reports generated using pytest-html or Allure after every test run.
excel/	        Contains test data files (Excel/CSV), used for data-driven testing with openpyxl or pandas.
batch_execution/	Includes batch files or shell scripts to trigger test execution from command line or CI/CD tools.

✅ How Components Work Together
“Each test case is written in a modular way using Pytest, which calls the page methods from POM.
 Test data is fetched from Excel using utility functions. Common actions like waits, logging, and 
screenshots are abstracted into the generic module. After execution, we generate detailed HTML reports and 
automatically capture screenshots on failure. We also maintain batch files to run complete test suites or selected
 scripts via command line or Jenkins pipelines.”

✅ Example Interview Answer (Complete)
“My framework is a hybrid approach using Python, Selenium, and Pytest. We use the Page Object Model to separate locators and 
methods for each page. Test cases are written under testcases/ using Pytest, and all reusable functions like waits, reading Excel, 
logging, and screenshots are placed in generic/. We follow a data-driven approach using Excel files placed in the excel/ folder.
 After execution, pytest-html or Allure generates detailed reports saved in reports/, and any failure automatically saves screenshots 
in the screenshots/ folder. For triggering executions, we use batch files from the batch_execution/ directory.
 This structure ensures high reusability, maintainability, and easy integration with Jenkins for CI.”

   
SELF INTRODUCTION.

Hi, my name is Harshan. I have over 4 years of experience as a associate Software  Engineer at Test Yantra Software Solutions.
 I have hands-on experience in both manual and automation testing, primarily using Python, Selenium, and Pytest.

I’ve worked extensively on automation frameworks like Page Object Model and Hybrid frameworks, 
where I contributed to designing reusable components, writing test scripts,
 and implementing data-driven testing using Excel. I’m also skilled in debugging, handling dynamic elements, and generating HTML reports using Pytest.

On the manual side, I’ve worked across the entire STLC, from writing and executing test cases to logging and 
tracking defects using JIRA. I have a strong understanding of Agile methodology and regularly participate in sprint planning,
 reviews, and retrospectives.
I’ve worked on projects in eCommerce and healthcare domains, where I also performed API testing using Postman, and database validation using SQL.

 







































